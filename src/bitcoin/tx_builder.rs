use std::{cell::RefCell, rc::Rc};

use bdk_wallet::{bitcoin::ScriptBuf, error::CreateTxError, Wallet as BdkWallet};
use serde::Serialize;
use wasm_bindgen::prelude::wasm_bindgen;

use crate::types::{Address, Amount, BdkError, BdkErrorCode, FeeRate, OutPoint, Psbt, Recipient};

/// A transaction builder.
///
/// A `TxBuilder` is created by calling [`build_tx`] or [`build_fee_bump`] on a wallet. After
/// assigning it, you set options on it until finally calling [`finish`] to consume the builder and
/// generate the transaction.
///
/// Each option setting method on `TxBuilder` takes and returns a new builder so you can chain calls
#[wasm_bindgen]
pub struct TxBuilder {
    wallet: Rc<RefCell<BdkWallet>>,
    recipients: Vec<Recipient>,
    unspendable: Vec<OutPoint>,
    fee_rate: FeeRate,
    drain_wallet: bool,
    drain_to: Option<ScriptBuf>,
    allow_dust: bool,
}

#[wasm_bindgen]
impl TxBuilder {
    // We make this constructor only visible to the crate to hide the use of the `Rc<RefCell<BdkWallet>>` in `Wallet::build_tx`.
    pub(crate) fn new(wallet: Rc<RefCell<BdkWallet>>) -> TxBuilder {
        TxBuilder {
            wallet,
            recipients: vec![],
            unspendable: vec![],
            fee_rate: FeeRate::new(1),
            drain_wallet: false,
            allow_dust: false,
            drain_to: None,
        }
    }

    /// Replace the recipients already added with a new list
    pub fn set_recipients(mut self, recipients: Vec<Recipient>) -> Self {
        self.recipients = recipients;
        self
    }

    /// Add a recipient to the internal list
    pub fn add_recipient(mut self, recipient: Recipient) -> Self {
        self.recipients.push(recipient);
        self
    }

    /// Replace the internal list of unspendable utxos with a new list
    pub fn unspendable(mut self, unspendable: Vec<OutPoint>) -> Self {
        self.unspendable = unspendable;
        self
    }

    /// Add a utxo to the internal list of unspendable utxos
    pub fn add_unspendable(mut self, outpoint: OutPoint) -> Self {
        self.unspendable.push(outpoint);
        self
    }

    /// Set a custom fee rate.
    ///
    /// This method sets the mining fee paid by the transaction as a rate on its size.
    /// This means that the total fee paid is equal to `fee_rate` times the size
    /// of the transaction. Default is 1 sat/vB in accordance with Bitcoin Core's default
    /// relay policy.
    ///
    /// Note that this is really a minimum feerate -- it's possible to
    /// overshoot it slightly since adding a change output to drain the remaining
    /// excess might not be viable.
    pub fn fee_rate(mut self, fee_rate: FeeRate) -> Self {
        self.fee_rate = fee_rate;
        self
    }

    /// Spend all the available inputs. This respects filters like [`TxBuilder::unspendable`] and the change policy.
    pub fn drain_wallet(mut self) -> Self {
        self.drain_wallet = true;
        self
    }

    /// Sets the address to *drain* excess coins to.
    ///
    /// Usually, when there are excess coins they are sent to a change address generated by the
    /// wallet. This option replaces the usual change address with an arbitrary `script_pubkey` of
    /// your choosing. Just as with a change output, if the drain output is not needed (the excess
    /// coins are too small) it will not be included in the resulting transaction. The only
    /// difference is that it is valid to use `drain_to` without setting any ordinary recipients
    /// with [`add_recipient`] (but it is perfectly fine to add recipients as well).
    ///
    /// If you choose not to set any recipients, you should provide the utxos that the
    /// transaction should spend via [`add_utxos`].
    pub fn drain_to(mut self, address: Address) -> Self {
        self.drain_to = Some(address.script_pubkey());
        self
    }

    /// Set whether or not the dust limit is checked.
    ///
    /// **Note**: by avoiding a dust limit check you may end up with a transaction that is non-standard.
    pub fn allow_dust(mut self, allow_dust: bool) -> Self {
        self.allow_dust = allow_dust;
        self
    }

    /// Finish building the transaction.
    ///
    /// Returns a new [`Psbt`] per [`BIP174`].
    pub fn finish(self) -> Result<Psbt, BdkError> {
        let mut wallet = self.wallet.borrow_mut();
        let mut builder = wallet.build_tx();

        builder
            .set_recipients(self.recipients.into_iter().map(Into::into).collect())
            .unspendable(self.unspendable.into_iter().map(Into::into).collect())
            .fee_rate(self.fee_rate.into())
            .allow_dust(self.allow_dust);

        if self.drain_wallet {
            builder.drain_wallet();
        }

        if let Some(drain_recipient) = self.drain_to {
            builder.drain_to(drain_recipient);
        }

        let psbt = builder.finish()?;
        Ok(psbt.into())
    }
}

/// Wallet's UTXO set is not enough to cover recipient's requested plus fee.
#[wasm_bindgen]
#[derive(Clone, Serialize)]
pub struct InsufficientFunds {
    /// Amount needed for the transaction
    pub needed: Amount,
    /// Amount available for spending
    pub available: Amount,
}

impl From<CreateTxError> for BdkError {
    fn from(e: CreateTxError) -> Self {
        use CreateTxError::*;
        match &e {
            Descriptor(_) => BdkError::new(BdkErrorCode::Descriptor, e.to_string(), ()),
            Policy(_) => BdkError::new(BdkErrorCode::Policy, e.to_string(), ()),
            SpendingPolicyRequired(keychain_kind) => {
                BdkError::new(BdkErrorCode::SpendingPolicyRequired, e.to_string(), keychain_kind)
            }
            Version0 => BdkError::new(BdkErrorCode::Version0, e.to_string(), ()),
            Version1Csv => BdkError::new(BdkErrorCode::Version1Csv, e.to_string(), ()),
            LockTime { .. } => BdkError::new(BdkErrorCode::LockTime, e.to_string(), ()),
            RbfSequenceCsv { .. } => BdkError::new(BdkErrorCode::RbfSequenceCsv, e.to_string(), ()),
            FeeTooLow { required } => BdkError::new(BdkErrorCode::FeeTooLow, e.to_string(), required),
            FeeRateTooLow { required } => BdkError::new(BdkErrorCode::FeeRateTooLow, e.to_string(), required),
            NoUtxosSelected => BdkError::new(BdkErrorCode::NoUtxosSelected, e.to_string(), ()),
            OutputBelowDustLimit(limit) => BdkError::new(BdkErrorCode::OutputBelowDustLimit, e.to_string(), limit),
            CoinSelection(insufficient_funds) => BdkError::new(
                BdkErrorCode::InsufficientFunds,
                e.to_string(),
                InsufficientFunds {
                    available: insufficient_funds.available.into(),
                    needed: insufficient_funds.needed.into(),
                },
            ),
            NoRecipients => BdkError::new(BdkErrorCode::NoRecipients, e.to_string(), ()),
            Psbt(_) => BdkError::new(BdkErrorCode::Psbt, e.to_string(), ()),
            MissingKeyOrigin(_) => BdkError::new(BdkErrorCode::MissingKeyOrigin, e.to_string(), ()),
            UnknownUtxo => BdkError::new(BdkErrorCode::UnknownUtxo, e.to_string(), ()),
            MissingNonWitnessUtxo(outpoint) => {
                BdkError::new(BdkErrorCode::MissingNonWitnessUtxo, e.to_string(), outpoint)
            }
            MiniscriptPsbt(_) => BdkError::new(BdkErrorCode::MiniscriptPsbt, e.to_string(), ()),
        }
    }
}
